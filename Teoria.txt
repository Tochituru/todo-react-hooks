Closure

La forma en que una función puede acceder a datos a través del contexto, no de forma explícita.

¿Qué es Hooks?

El 80 % de la magia de react ocurre en React.Component. (Los métodos básicos de ComponentDidMount, etc)

No obstante, React no permite utilizarlo en los functional components. A menos que usemos Hooks.

Literalmente, hackearon la clase Component, tomaron las cosas copadas y las expusieron para que Functional Components puedan utilizarlas. Esto son los hooks.

Con eso, podemos desarrollar una app que hace lo mismo que todolist de manera más legible, más escalable y, sobre todo, en muchas menos líneas de código.

Hooks utiliza el paradigma de programación funcional.
Este paradigma trata las funciones como datos. A una función podemos pasarle otras funciones (por eso se trabaja con funciones puras).

¿Cómo usamos Hooks?

En un functional component, que ahora será App.js, importamos {useState}
Es una función.

Luego lo desestructuramos antes del return.
Su destructuración siempre devuelve una tupla:
- getter --> el estado inicial (nos da datos)
- setter --> con el que vamos a modificar (modifica los datos)

    let [state, setState] = useState('titulo')

En la función en sí (useState), vamos a pasarle un parámetro, que será el contenido del getter.

Luego, establecemos un evento (como onClick), al que le agregamos la función setState('parámetro'). Cuando yo hago click, ejecuta el evento onclick, llama al setter y ejecuta ese valor. 

Podemos usar useState cuantas veces queramos, y podemos llamar su getter y setter como se nos cante.

El getter va a ser el estado inicial que decidamos. Puede estar vacío, ser una string y hasta ser un objeto.
En caso de ser un objeto, deberemos llamar a las propiedades del objeto para los valores y demáses.
IMPORTANTE: Si es vacío, marcarlo como tal ('', [''], {''} ) para que no quede como undefined.

Hooks permite manejar varias tuplas a la vez. No obstante, conviene manejar un useState a la vez y tener varios manejadores de estado externos a los componentes. Los proyectos levantan un hooks (hecho manualmente) con el estado de la aplicación y si hace falta, un hook local para ese componente.

{useEffect}
Es una función que permite hacer un montón de cosas. Depende de nosotras determinar cómo funciona.
Casi todas las cosas que arrancan con "use" son hooks.

Es una función que recibe al menos dos parámetros. 
El primero es una función propiamente dicha.
Primero, probamos un console log.
Aparece al principio de todo porque es el equivalente de ComponentDidMount. 
El comportamiento default es tomar el contenido del primer parámetro (en este caso, el consolelog) y ejecutarlo cuando se cumple lo que conocemos como ComponentDidMount.
Se sigue disparando cada vez que hago una modificación en el estado. Combina ComponentDidMount con ComponentDidUpdate.

Si tenemos operaciones costosas en cuanto a algoritmos, no queremos que se repita tantas veces.

CUando usábamos ComponentDidUpdate, hicimos que se persista todo el contenido, sin ninguna clase de fondo.

ComponentDidUpdate normalmente recibe dos parámetros: perviousState (el estado anterior, que podría levantar). No obstante, sigue tomando un montón de memoria.

El segundo parámetro de useEffect es una lista. En este caso, será todoList. Así, le decimos que quiero que se ejecute una vez cuando se ejecuta la aplicaicón y quiero que te suscribas (estar pendiente de algo) al estado y cuando sea modificado, ejecuta lo que tengo arriba (el primer parámetro).

Esto, a nivel de rendimiento, es la gloria. 


